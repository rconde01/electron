From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Shelley Vohr <shelley.vohr@gmail.com>
Date: Tue, 4 Feb 2020 08:59:32 -0700
Subject: Revert "Remove ContentRendererClient::ShouldFork."

This reverts the CL at https://chromium-review.googlesource.com/c/chromium/src/+/1812128.
We use it to force a new renderer process for navigations, and need to start a new renderer process
for every navigation to keep Node.js working properly. Once Native Modules in the renderer process
are required to be NAPI or context aware (Electron v11), this patch can be removed.

diff --git a/chrome/renderer/chrome_content_renderer_client.cc b/chrome/renderer/chrome_content_renderer_client.cc
index 8e349fd7d222e40a1eae91961303de3b90f7d697..f1ca8ab5ed1532f76257add7cf5b11b55ed9009d 100644
--- a/chrome/renderer/chrome_content_renderer_client.cc
+++ b/chrome/renderer/chrome_content_renderer_client.cc
@@ -1295,6 +1295,25 @@ bool ChromeContentRendererClient::AllowPopup() {
 #endif
 }
 
+bool ChromeContentRendererClient::ShouldFork(WebLocalFrame* frame,
+                                             const GURL& url,
+                                             const std::string& http_method,
+                                             bool is_initial_navigation,
+                                             bool is_server_redirect) {
+  DCHECK(!frame->Parent());
+
+  // If |url| matches one of the prerendered URLs, stop this navigation and try
+  // to swap in the prerendered page on the browser process. If the prerendered
+  // page no longer exists by the time the OpenURL IPC is handled, a normal
+  // navigation is attempted.
+  if (prerender_dispatcher_.get() &&
+      prerender_dispatcher_->IsPrerenderURL(url)) {
+    return true;
+  }
+
+  return false;
+}
+
 void ChromeContentRendererClient::WillSendRequest(
     WebLocalFrame* frame,
     ui::PageTransition transition_type,
diff --git a/chrome/renderer/chrome_content_renderer_client.h b/chrome/renderer/chrome_content_renderer_client.h
index 416b7a8f3ba1b6941761c1df4ea108219c415489..2733d0dbbc10c5465a319b080d9b079258ba896d 100644
--- a/chrome/renderer/chrome_content_renderer_client.h
+++ b/chrome/renderer/chrome_content_renderer_client.h
@@ -127,6 +127,11 @@ class ChromeContentRendererClient
       base::SingleThreadTaskRunner* compositor_thread_task_runner) override;
   bool RunIdleHandlerWhenWidgetsHidden() override;
   bool AllowPopup() override;
+  bool ShouldFork(blink::WebLocalFrame* frame,
+                const GURL& url,
+                const std::string& http_method,
+                bool is_initial_navigation,
+                bool is_server_redirect) override;
   void WillSendRequest(blink::WebLocalFrame* frame,
                        ui::PageTransition transition_type,
                        const blink::WebURL& url,
diff --git a/content/public/renderer/content_renderer_client.cc b/content/public/renderer/content_renderer_client.cc
index ea6d8e6357233f519c3cf41a96d8453993a9ce71..c513aff3e1c3da45e45954bc0beb80469de6a450 100644
--- a/content/public/renderer/content_renderer_client.cc
+++ b/content/public/renderer/content_renderer_client.cc
@@ -114,6 +114,14 @@ bool ContentRendererClient::HandleNavigation(
 }
 #endif
 
+bool ContentRendererClient::ShouldFork(blink::WebLocalFrame* frame,
+                                       const GURL& url,
+                                       const std::string& http_method,
+                                       bool is_initial_navigation,
+                                       bool is_server_redirect) {
+  return false;
+}
+
 void ContentRendererClient::WillSendRequest(
     blink::WebLocalFrame* frame,
     ui::PageTransition transition_type,
diff --git a/content/public/renderer/content_renderer_client.h b/content/public/renderer/content_renderer_client.h
index de0274d03ff1a0838f0ab0002c5a6b6ea7e10bfd..892366cd9d2f70498e2e7429a66dcf135d79bb27 100644
--- a/content/public/renderer/content_renderer_client.h
+++ b/content/public/renderer/content_renderer_client.h
@@ -227,6 +227,13 @@ class CONTENT_EXPORT ContentRendererClient {
                                 bool is_redirect);
 #endif
 
+  // Returns true if we should fork a new process for the given navigation.
+  virtual bool ShouldFork(blink::WebLocalFrame* frame,
+                          const GURL& url,
+                          const std::string& http_method,
+                          bool is_initial_navigation,
+                          bool is_server_redirect);
+
   // Notifies the embedder that the given frame is requesting the resource at
   // |url|. If the function returns a valid |new_url|, the request must be
   // updated to use it. The |force_ignore_site_for_cookies| output parameter
diff --git a/content/renderer/render_frame_impl.cc b/content/renderer/render_frame_impl.cc
index dfb5715ce5d91e942694beb02276bdd9a4063323..b3aeb0da5449d63d13e3c66b16ed6a6f03d0348b 100644
--- a/content/renderer/render_frame_impl.cc
+++ b/content/renderer/render_frame_impl.cc
@@ -5623,6 +5623,23 @@ void RenderFrameImpl::BeginNavigation(
     // we can do a per-frame check here rather than a process-wide check.
     bool should_fork = HasWebUIScheme(url) || HasWebUIScheme(old_url) ||
                        (enabled_bindings_ & kWebUIBindingsPolicyMask);
+
+    if (!should_fork && url.SchemeIs(url::kFileScheme)) {
+      // Fork non-file to file opens (see https://crbug.com/1031119).  Note that
+      // this may fork unnecessarily if another tab (hosting a file or not)
+      // targeted this one before its initial navigation, but that shouldn't
+      // cause a problem.
+      should_fork = !old_url.SchemeIs(url::kFileScheme);
+    }
+
+    if (!should_fork) {
+      // Give the embedder a chance.
+      bool is_initial_navigation = render_view_->history_list_length_ == 0;
+      should_fork = GetContentClient()->renderer()->ShouldFork(
+          frame_, url, info->url_request.HttpMethod().Utf8(),
+          is_initial_navigation, false /* is_redirect */);
+    }
+
     if (should_fork) {
       OpenURL(std::move(info));
       return;  // Suppress the load here.
